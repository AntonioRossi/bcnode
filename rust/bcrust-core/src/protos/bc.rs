// This file is generated by rust-protobuf 2.0.4. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct GetLatestBlocksResponse {
    // message fields
    pub blocks: ::protobuf::RepeatedField<super::core::Block>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetLatestBlocksResponse {
    pub fn new() -> GetLatestBlocksResponse {
        ::std::default::Default::default()
    }

    // repeated .bc.Block blocks = 1;

    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::core::Block>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::core::Block> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::core::Block> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_blocks(&self) -> &[super::core::Block] {
        &self.blocks
    }
}

impl ::protobuf::Message for GetLatestBlocksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLatestBlocksResponse {
        GetLatestBlocksResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::core::Block>>(
                    "blocks",
                    |m: &GetLatestBlocksResponse| { &m.blocks },
                    |m: &mut GetLatestBlocksResponse| { &mut m.blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetLatestBlocksResponse>(
                    "GetLatestBlocksResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetLatestBlocksResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetLatestBlocksResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLatestBlocksResponse,
        };
        unsafe {
            instance.get(GetLatestBlocksResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetLatestBlocksResponse {
    fn clear(&mut self) {
        self.clear_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLatestBlocksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLatestBlocksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HelpResponse {
    // message fields
    pub help_text: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl HelpResponse {
    pub fn new() -> HelpResponse {
        ::std::default::Default::default()
    }

    // string help_text = 1;

    pub fn clear_help_text(&mut self) {
        self.help_text.clear();
    }

    // Param is passed by value, moved
    pub fn set_help_text(&mut self, v: ::std::string::String) {
        self.help_text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_help_text(&mut self) -> &mut ::std::string::String {
        &mut self.help_text
    }

    // Take field
    pub fn take_help_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.help_text, ::std::string::String::new())
    }

    pub fn get_help_text(&self) -> &str {
        &self.help_text
    }
}

impl ::protobuf::Message for HelpResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.help_text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.help_text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.help_text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.help_text.is_empty() {
            os.write_string(1, &self.help_text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelpResponse {
        HelpResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "help_text",
                    |m: &HelpResponse| { &m.help_text },
                    |m: &mut HelpResponse| { &mut m.help_text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HelpResponse>(
                    "HelpResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HelpResponse {
        static mut instance: ::protobuf::lazy::Lazy<HelpResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HelpResponse,
        };
        unsafe {
            instance.get(HelpResponse::new)
        }
    }
}

impl ::protobuf::Clear for HelpResponse {
    fn clear(&mut self) {
        self.clear_help_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelpResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelpResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatsResponse {
    // message fields
    pub calls: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StatsResponse {
    pub fn new() -> StatsResponse {
        ::std::default::Default::default()
    }

    // int64 calls = 1;

    pub fn clear_calls(&mut self) {
        self.calls = 0;
    }

    // Param is passed by value, moved
    pub fn set_calls(&mut self, v: i64) {
        self.calls = v;
    }

    pub fn get_calls(&self) -> i64 {
        self.calls
    }
}

impl ::protobuf::Message for StatsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.calls = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.calls != 0 {
            my_size += ::protobuf::rt::value_size(1, self.calls, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.calls != 0 {
            os.write_int64(1, self.calls)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatsResponse {
        StatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "calls",
                    |m: &StatsResponse| { &m.calls },
                    |m: &mut StatsResponse| { &mut m.calls },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatsResponse>(
                    "StatsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatsResponse {
        static mut instance: ::protobuf::lazy::Lazy<StatsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatsResponse,
        };
        unsafe {
            instance.get(StatsResponse::new)
        }
    }
}

impl ::protobuf::Clear for StatsResponse {
    fn clear(&mut self) {
        self.clear_calls();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RpcTransaction {
    // message fields
    pub from_addr: ::std::string::String,
    pub to_addr: ::std::string::String,
    pub amount: ::std::vec::Vec<u8>,
    pub tx_fee: ::std::vec::Vec<u8>,
    pub private_key_hex: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RpcTransaction {
    pub fn new() -> RpcTransaction {
        ::std::default::Default::default()
    }

    // string from_addr = 1;

    pub fn clear_from_addr(&mut self) {
        self.from_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_addr(&mut self, v: ::std::string::String) {
        self.from_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_addr(&mut self) -> &mut ::std::string::String {
        &mut self.from_addr
    }

    // Take field
    pub fn take_from_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from_addr, ::std::string::String::new())
    }

    pub fn get_from_addr(&self) -> &str {
        &self.from_addr
    }

    // string to_addr = 2;

    pub fn clear_to_addr(&mut self) {
        self.to_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_to_addr(&mut self, v: ::std::string::String) {
        self.to_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_addr(&mut self) -> &mut ::std::string::String {
        &mut self.to_addr
    }

    // Take field
    pub fn take_to_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.to_addr, ::std::string::String::new())
    }

    pub fn get_to_addr(&self) -> &str {
        &self.to_addr
    }

    // bytes amount = 3;

    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::vec::Vec<u8>) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.amount, ::std::vec::Vec::new())
    }

    pub fn get_amount(&self) -> &[u8] {
        &self.amount
    }

    // bytes tx_fee = 4;

    pub fn clear_tx_fee(&mut self) {
        self.tx_fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_fee(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_fee(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tx_fee
    }

    // Take field
    pub fn take_tx_fee(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tx_fee, ::std::vec::Vec::new())
    }

    pub fn get_tx_fee(&self) -> &[u8] {
        &self.tx_fee
    }

    // string private_key_hex = 5;

    pub fn clear_private_key_hex(&mut self) {
        self.private_key_hex.clear();
    }

    // Param is passed by value, moved
    pub fn set_private_key_hex(&mut self, v: ::std::string::String) {
        self.private_key_hex = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_private_key_hex(&mut self) -> &mut ::std::string::String {
        &mut self.private_key_hex
    }

    // Take field
    pub fn take_private_key_hex(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.private_key_hex, ::std::string::String::new())
    }

    pub fn get_private_key_hex(&self) -> &str {
        &self.private_key_hex
    }
}

impl ::protobuf::Message for RpcTransaction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.to_addr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.amount)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.tx_fee)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.private_key_hex)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.from_addr);
        }
        if !self.to_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.to_addr);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.amount);
        }
        if !self.tx_fee.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.tx_fee);
        }
        if !self.private_key_hex.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.private_key_hex);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.from_addr.is_empty() {
            os.write_string(1, &self.from_addr)?;
        }
        if !self.to_addr.is_empty() {
            os.write_string(2, &self.to_addr)?;
        }
        if !self.amount.is_empty() {
            os.write_bytes(3, &self.amount)?;
        }
        if !self.tx_fee.is_empty() {
            os.write_bytes(4, &self.tx_fee)?;
        }
        if !self.private_key_hex.is_empty() {
            os.write_string(5, &self.private_key_hex)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RpcTransaction {
        RpcTransaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "from_addr",
                    |m: &RpcTransaction| { &m.from_addr },
                    |m: &mut RpcTransaction| { &mut m.from_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "to_addr",
                    |m: &RpcTransaction| { &m.to_addr },
                    |m: &mut RpcTransaction| { &mut m.to_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "amount",
                    |m: &RpcTransaction| { &m.amount },
                    |m: &mut RpcTransaction| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "tx_fee",
                    |m: &RpcTransaction| { &m.tx_fee },
                    |m: &mut RpcTransaction| { &mut m.tx_fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "private_key_hex",
                    |m: &RpcTransaction| { &m.private_key_hex },
                    |m: &mut RpcTransaction| { &mut m.private_key_hex },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RpcTransaction>(
                    "RpcTransaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RpcTransaction {
        static mut instance: ::protobuf::lazy::Lazy<RpcTransaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RpcTransaction,
        };
        unsafe {
            instance.get(RpcTransaction::new)
        }
    }
}

impl ::protobuf::Clear for RpcTransaction {
    fn clear(&mut self) {
        self.clear_from_addr();
        self.clear_to_addr();
        self.clear_amount();
        self.clear_tx_fee();
        self.clear_private_key_hex();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RpcTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcTransaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RpcTransactionResponse {
    // message fields
    pub status: RpcTransactionResponseStatus,
    pub tx_hash: ::std::string::String,
    pub error: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RpcTransactionResponse {
    pub fn new() -> RpcTransactionResponse {
        ::std::default::Default::default()
    }

    // .bc.RpcTransactionResponseStatus status = 1;

    pub fn clear_status(&mut self) {
        self.status = RpcTransactionResponseStatus::Success;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: RpcTransactionResponseStatus) {
        self.status = v;
    }

    pub fn get_status(&self) -> RpcTransactionResponseStatus {
        self.status
    }

    // string tx_hash = 2;

    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }

    // string error = 3;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    pub fn get_error(&self) -> &str {
        &self.error
    }
}

impl ::protobuf::Message for RpcTransactionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != RpcTransactionResponseStatus::Success {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tx_hash);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.status != RpcTransactionResponseStatus::Success {
            os.write_enum(1, self.status.value())?;
        }
        if !self.tx_hash.is_empty() {
            os.write_string(2, &self.tx_hash)?;
        }
        if !self.error.is_empty() {
            os.write_string(3, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RpcTransactionResponse {
        RpcTransactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RpcTransactionResponseStatus>>(
                    "status",
                    |m: &RpcTransactionResponse| { &m.status },
                    |m: &mut RpcTransactionResponse| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx_hash",
                    |m: &RpcTransactionResponse| { &m.tx_hash },
                    |m: &mut RpcTransactionResponse| { &mut m.tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &RpcTransactionResponse| { &m.error },
                    |m: &mut RpcTransactionResponse| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RpcTransactionResponse>(
                    "RpcTransactionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RpcTransactionResponse {
        static mut instance: ::protobuf::lazy::Lazy<RpcTransactionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RpcTransactionResponse,
        };
        unsafe {
            instance.get(RpcTransactionResponse::new)
        }
    }
}

impl ::protobuf::Clear for RpcTransactionResponse {
    fn clear(&mut self) {
        self.clear_status();
        self.clear_tx_hash();
        self.clear_error();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RpcTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcTransactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBalanceRequest {
    // message fields
    pub address: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBalanceRequest {
    pub fn new() -> GetBalanceRequest {
        ::std::default::Default::default()
    }

    // string address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    pub fn get_address(&self) -> &str {
        &self.address
    }
}

impl ::protobuf::Message for GetBalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBalanceRequest {
        GetBalanceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &GetBalanceRequest| { &m.address },
                    |m: &mut GetBalanceRequest| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBalanceRequest>(
                    "GetBalanceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBalanceRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetBalanceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBalanceRequest,
        };
        unsafe {
            instance.get(GetBalanceRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetBalanceRequest {
    fn clear(&mut self) {
        self.clear_address();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBalanceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBalanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBalanceResponse {
    // message fields
    pub confirmed: ::std::string::String,
    pub unconfirmed: ::std::string::String,
    pub unit: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBalanceResponse {
    pub fn new() -> GetBalanceResponse {
        ::std::default::Default::default()
    }

    // string confirmed = 1;

    pub fn clear_confirmed(&mut self) {
        self.confirmed.clear();
    }

    // Param is passed by value, moved
    pub fn set_confirmed(&mut self, v: ::std::string::String) {
        self.confirmed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_confirmed(&mut self) -> &mut ::std::string::String {
        &mut self.confirmed
    }

    // Take field
    pub fn take_confirmed(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.confirmed, ::std::string::String::new())
    }

    pub fn get_confirmed(&self) -> &str {
        &self.confirmed
    }

    // string unconfirmed = 2;

    pub fn clear_unconfirmed(&mut self) {
        self.unconfirmed.clear();
    }

    // Param is passed by value, moved
    pub fn set_unconfirmed(&mut self, v: ::std::string::String) {
        self.unconfirmed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unconfirmed(&mut self) -> &mut ::std::string::String {
        &mut self.unconfirmed
    }

    // Take field
    pub fn take_unconfirmed(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unconfirmed, ::std::string::String::new())
    }

    pub fn get_unconfirmed(&self) -> &str {
        &self.unconfirmed
    }

    // string unit = 3;

    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: ::std::string::String) {
        self.unit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut ::std::string::String {
        &mut self.unit
    }

    // Take field
    pub fn take_unit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unit, ::std::string::String::new())
    }

    pub fn get_unit(&self) -> &str {
        &self.unit
    }
}

impl ::protobuf::Message for GetBalanceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.confirmed)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unconfirmed)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.confirmed.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.confirmed);
        }
        if !self.unconfirmed.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.unconfirmed);
        }
        if !self.unit.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.unit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.confirmed.is_empty() {
            os.write_string(1, &self.confirmed)?;
        }
        if !self.unconfirmed.is_empty() {
            os.write_string(2, &self.unconfirmed)?;
        }
        if !self.unit.is_empty() {
            os.write_string(3, &self.unit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBalanceResponse {
        GetBalanceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "confirmed",
                    |m: &GetBalanceResponse| { &m.confirmed },
                    |m: &mut GetBalanceResponse| { &mut m.confirmed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "unconfirmed",
                    |m: &GetBalanceResponse| { &m.unconfirmed },
                    |m: &mut GetBalanceResponse| { &mut m.unconfirmed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "unit",
                    |m: &GetBalanceResponse| { &m.unit },
                    |m: &mut GetBalanceResponse| { &mut m.unit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBalanceResponse>(
                    "GetBalanceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBalanceResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetBalanceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBalanceResponse,
        };
        unsafe {
            instance.get(GetBalanceResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetBalanceResponse {
    fn clear(&mut self) {
        self.clear_confirmed();
        self.clear_unconfirmed();
        self.clear_unit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBalanceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBalanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MakerOrderInfo {
    // message fields
    pub shift_starts_at: u64,
    pub deposit_ends_at: u64,
    pub settle_ends_at: u64,
    pub pays_chain_id: ::std::string::String,
    pub wants_chain_id: ::std::string::String,
    pub wants_address: ::std::string::String,
    pub wants_unit: ::std::string::String,
    pub pays_unit: ::std::string::String,
    pub bc_address: ::std::string::String,
    pub collateralized_nrg: ::std::string::String,
    pub nrg_unit: ::std::string::String,
    pub tx_hash: ::std::string::String,
    pub tx_output_index: u64,
    pub block_hash: ::std::string::String,
    pub block_height: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MakerOrderInfo {
    pub fn new() -> MakerOrderInfo {
        ::std::default::Default::default()
    }

    // uint64 shift_starts_at = 1;

    pub fn clear_shift_starts_at(&mut self) {
        self.shift_starts_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_shift_starts_at(&mut self, v: u64) {
        self.shift_starts_at = v;
    }

    pub fn get_shift_starts_at(&self) -> u64 {
        self.shift_starts_at
    }

    // uint64 deposit_ends_at = 2;

    pub fn clear_deposit_ends_at(&mut self) {
        self.deposit_ends_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_deposit_ends_at(&mut self, v: u64) {
        self.deposit_ends_at = v;
    }

    pub fn get_deposit_ends_at(&self) -> u64 {
        self.deposit_ends_at
    }

    // uint64 settle_ends_at = 3;

    pub fn clear_settle_ends_at(&mut self) {
        self.settle_ends_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_ends_at(&mut self, v: u64) {
        self.settle_ends_at = v;
    }

    pub fn get_settle_ends_at(&self) -> u64 {
        self.settle_ends_at
    }

    // string pays_chain_id = 4;

    pub fn clear_pays_chain_id(&mut self) {
        self.pays_chain_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pays_chain_id(&mut self, v: ::std::string::String) {
        self.pays_chain_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pays_chain_id(&mut self) -> &mut ::std::string::String {
        &mut self.pays_chain_id
    }

    // Take field
    pub fn take_pays_chain_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pays_chain_id, ::std::string::String::new())
    }

    pub fn get_pays_chain_id(&self) -> &str {
        &self.pays_chain_id
    }

    // string wants_chain_id = 5;

    pub fn clear_wants_chain_id(&mut self) {
        self.wants_chain_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_wants_chain_id(&mut self, v: ::std::string::String) {
        self.wants_chain_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wants_chain_id(&mut self) -> &mut ::std::string::String {
        &mut self.wants_chain_id
    }

    // Take field
    pub fn take_wants_chain_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wants_chain_id, ::std::string::String::new())
    }

    pub fn get_wants_chain_id(&self) -> &str {
        &self.wants_chain_id
    }

    // string wants_address = 6;

    pub fn clear_wants_address(&mut self) {
        self.wants_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_wants_address(&mut self, v: ::std::string::String) {
        self.wants_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wants_address(&mut self) -> &mut ::std::string::String {
        &mut self.wants_address
    }

    // Take field
    pub fn take_wants_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wants_address, ::std::string::String::new())
    }

    pub fn get_wants_address(&self) -> &str {
        &self.wants_address
    }

    // string wants_unit = 7;

    pub fn clear_wants_unit(&mut self) {
        self.wants_unit.clear();
    }

    // Param is passed by value, moved
    pub fn set_wants_unit(&mut self, v: ::std::string::String) {
        self.wants_unit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wants_unit(&mut self) -> &mut ::std::string::String {
        &mut self.wants_unit
    }

    // Take field
    pub fn take_wants_unit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wants_unit, ::std::string::String::new())
    }

    pub fn get_wants_unit(&self) -> &str {
        &self.wants_unit
    }

    // string pays_unit = 8;

    pub fn clear_pays_unit(&mut self) {
        self.pays_unit.clear();
    }

    // Param is passed by value, moved
    pub fn set_pays_unit(&mut self, v: ::std::string::String) {
        self.pays_unit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pays_unit(&mut self) -> &mut ::std::string::String {
        &mut self.pays_unit
    }

    // Take field
    pub fn take_pays_unit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pays_unit, ::std::string::String::new())
    }

    pub fn get_pays_unit(&self) -> &str {
        &self.pays_unit
    }

    // string bc_address = 9;

    pub fn clear_bc_address(&mut self) {
        self.bc_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_bc_address(&mut self, v: ::std::string::String) {
        self.bc_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bc_address(&mut self) -> &mut ::std::string::String {
        &mut self.bc_address
    }

    // Take field
    pub fn take_bc_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bc_address, ::std::string::String::new())
    }

    pub fn get_bc_address(&self) -> &str {
        &self.bc_address
    }

    // string collateralized_nrg = 10;

    pub fn clear_collateralized_nrg(&mut self) {
        self.collateralized_nrg.clear();
    }

    // Param is passed by value, moved
    pub fn set_collateralized_nrg(&mut self, v: ::std::string::String) {
        self.collateralized_nrg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collateralized_nrg(&mut self) -> &mut ::std::string::String {
        &mut self.collateralized_nrg
    }

    // Take field
    pub fn take_collateralized_nrg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collateralized_nrg, ::std::string::String::new())
    }

    pub fn get_collateralized_nrg(&self) -> &str {
        &self.collateralized_nrg
    }

    // string nrg_unit = 11;

    pub fn clear_nrg_unit(&mut self) {
        self.nrg_unit.clear();
    }

    // Param is passed by value, moved
    pub fn set_nrg_unit(&mut self, v: ::std::string::String) {
        self.nrg_unit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nrg_unit(&mut self) -> &mut ::std::string::String {
        &mut self.nrg_unit
    }

    // Take field
    pub fn take_nrg_unit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nrg_unit, ::std::string::String::new())
    }

    pub fn get_nrg_unit(&self) -> &str {
        &self.nrg_unit
    }

    // string tx_hash = 12;

    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }

    // uint64 tx_output_index = 13;

    pub fn clear_tx_output_index(&mut self) {
        self.tx_output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_output_index(&mut self, v: u64) {
        self.tx_output_index = v;
    }

    pub fn get_tx_output_index(&self) -> u64 {
        self.tx_output_index
    }

    // string block_hash = 14;

    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }

    // uint64 block_height = 15;

    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: u64) {
        self.block_height = v;
    }

    pub fn get_block_height(&self) -> u64 {
        self.block_height
    }
}

impl ::protobuf::Message for MakerOrderInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.shift_starts_at = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.deposit_ends_at = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.settle_ends_at = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pays_chain_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wants_chain_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wants_address)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wants_unit)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pays_unit)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bc_address)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collateralized_nrg)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nrg_unit)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_output_index = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_hash)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shift_starts_at != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shift_starts_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.deposit_ends_at != 0 {
            my_size += ::protobuf::rt::value_size(2, self.deposit_ends_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_ends_at != 0 {
            my_size += ::protobuf::rt::value_size(3, self.settle_ends_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pays_chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.pays_chain_id);
        }
        if !self.wants_chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.wants_chain_id);
        }
        if !self.wants_address.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.wants_address);
        }
        if !self.wants_unit.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.wants_unit);
        }
        if !self.pays_unit.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.pays_unit);
        }
        if !self.bc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.bc_address);
        }
        if !self.collateralized_nrg.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.collateralized_nrg);
        }
        if !self.nrg_unit.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.nrg_unit);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.tx_hash);
        }
        if self.tx_output_index != 0 {
            my_size += ::protobuf::rt::value_size(13, self.tx_output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.block_hash);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(15, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.shift_starts_at != 0 {
            os.write_uint64(1, self.shift_starts_at)?;
        }
        if self.deposit_ends_at != 0 {
            os.write_uint64(2, self.deposit_ends_at)?;
        }
        if self.settle_ends_at != 0 {
            os.write_uint64(3, self.settle_ends_at)?;
        }
        if !self.pays_chain_id.is_empty() {
            os.write_string(4, &self.pays_chain_id)?;
        }
        if !self.wants_chain_id.is_empty() {
            os.write_string(5, &self.wants_chain_id)?;
        }
        if !self.wants_address.is_empty() {
            os.write_string(6, &self.wants_address)?;
        }
        if !self.wants_unit.is_empty() {
            os.write_string(7, &self.wants_unit)?;
        }
        if !self.pays_unit.is_empty() {
            os.write_string(8, &self.pays_unit)?;
        }
        if !self.bc_address.is_empty() {
            os.write_string(9, &self.bc_address)?;
        }
        if !self.collateralized_nrg.is_empty() {
            os.write_string(10, &self.collateralized_nrg)?;
        }
        if !self.nrg_unit.is_empty() {
            os.write_string(11, &self.nrg_unit)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_string(12, &self.tx_hash)?;
        }
        if self.tx_output_index != 0 {
            os.write_uint64(13, self.tx_output_index)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(14, &self.block_hash)?;
        }
        if self.block_height != 0 {
            os.write_uint64(15, self.block_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MakerOrderInfo {
        MakerOrderInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "shift_starts_at",
                    |m: &MakerOrderInfo| { &m.shift_starts_at },
                    |m: &mut MakerOrderInfo| { &mut m.shift_starts_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "deposit_ends_at",
                    |m: &MakerOrderInfo| { &m.deposit_ends_at },
                    |m: &mut MakerOrderInfo| { &mut m.deposit_ends_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "settle_ends_at",
                    |m: &MakerOrderInfo| { &m.settle_ends_at },
                    |m: &mut MakerOrderInfo| { &mut m.settle_ends_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pays_chain_id",
                    |m: &MakerOrderInfo| { &m.pays_chain_id },
                    |m: &mut MakerOrderInfo| { &mut m.pays_chain_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wants_chain_id",
                    |m: &MakerOrderInfo| { &m.wants_chain_id },
                    |m: &mut MakerOrderInfo| { &mut m.wants_chain_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wants_address",
                    |m: &MakerOrderInfo| { &m.wants_address },
                    |m: &mut MakerOrderInfo| { &mut m.wants_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wants_unit",
                    |m: &MakerOrderInfo| { &m.wants_unit },
                    |m: &mut MakerOrderInfo| { &mut m.wants_unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pays_unit",
                    |m: &MakerOrderInfo| { &m.pays_unit },
                    |m: &mut MakerOrderInfo| { &mut m.pays_unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bc_address",
                    |m: &MakerOrderInfo| { &m.bc_address },
                    |m: &mut MakerOrderInfo| { &mut m.bc_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collateralized_nrg",
                    |m: &MakerOrderInfo| { &m.collateralized_nrg },
                    |m: &mut MakerOrderInfo| { &mut m.collateralized_nrg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nrg_unit",
                    |m: &MakerOrderInfo| { &m.nrg_unit },
                    |m: &mut MakerOrderInfo| { &mut m.nrg_unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx_hash",
                    |m: &MakerOrderInfo| { &m.tx_hash },
                    |m: &mut MakerOrderInfo| { &mut m.tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tx_output_index",
                    |m: &MakerOrderInfo| { &m.tx_output_index },
                    |m: &mut MakerOrderInfo| { &mut m.tx_output_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "block_hash",
                    |m: &MakerOrderInfo| { &m.block_hash },
                    |m: &mut MakerOrderInfo| { &mut m.block_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "block_height",
                    |m: &MakerOrderInfo| { &m.block_height },
                    |m: &mut MakerOrderInfo| { &mut m.block_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MakerOrderInfo>(
                    "MakerOrderInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MakerOrderInfo {
        static mut instance: ::protobuf::lazy::Lazy<MakerOrderInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MakerOrderInfo,
        };
        unsafe {
            instance.get(MakerOrderInfo::new)
        }
    }
}

impl ::protobuf::Clear for MakerOrderInfo {
    fn clear(&mut self) {
        self.clear_shift_starts_at();
        self.clear_deposit_ends_at();
        self.clear_settle_ends_at();
        self.clear_pays_chain_id();
        self.clear_wants_chain_id();
        self.clear_wants_address();
        self.clear_wants_unit();
        self.clear_pays_unit();
        self.clear_bc_address();
        self.clear_collateralized_nrg();
        self.clear_nrg_unit();
        self.clear_tx_hash();
        self.clear_tx_output_index();
        self.clear_block_hash();
        self.clear_block_height();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MakerOrderInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MakerOrderInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TakerOrderInfo {
    // message fields
    pub sends_address: ::std::string::String,
    pub wants_address: ::std::string::String,
    pub maker_tx_hash: ::std::string::String,
    pub maker_tx_output_index: u32,
    pub bc_address: ::std::string::String,
    pub collateralized_nrg: ::std::string::String,
    pub block_hash: ::std::string::String,
    pub block_height: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TakerOrderInfo {
    pub fn new() -> TakerOrderInfo {
        ::std::default::Default::default()
    }

    // string sends_address = 1;

    pub fn clear_sends_address(&mut self) {
        self.sends_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_sends_address(&mut self, v: ::std::string::String) {
        self.sends_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sends_address(&mut self) -> &mut ::std::string::String {
        &mut self.sends_address
    }

    // Take field
    pub fn take_sends_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sends_address, ::std::string::String::new())
    }

    pub fn get_sends_address(&self) -> &str {
        &self.sends_address
    }

    // string wants_address = 2;

    pub fn clear_wants_address(&mut self) {
        self.wants_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_wants_address(&mut self, v: ::std::string::String) {
        self.wants_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wants_address(&mut self) -> &mut ::std::string::String {
        &mut self.wants_address
    }

    // Take field
    pub fn take_wants_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wants_address, ::std::string::String::new())
    }

    pub fn get_wants_address(&self) -> &str {
        &self.wants_address
    }

    // string maker_tx_hash = 3;

    pub fn clear_maker_tx_hash(&mut self) {
        self.maker_tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_tx_hash(&mut self, v: ::std::string::String) {
        self.maker_tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.maker_tx_hash
    }

    // Take field
    pub fn take_maker_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_tx_hash, ::std::string::String::new())
    }

    pub fn get_maker_tx_hash(&self) -> &str {
        &self.maker_tx_hash
    }

    // uint32 maker_tx_output_index = 4;

    pub fn clear_maker_tx_output_index(&mut self) {
        self.maker_tx_output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_maker_tx_output_index(&mut self, v: u32) {
        self.maker_tx_output_index = v;
    }

    pub fn get_maker_tx_output_index(&self) -> u32 {
        self.maker_tx_output_index
    }

    // string bc_address = 5;

    pub fn clear_bc_address(&mut self) {
        self.bc_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_bc_address(&mut self, v: ::std::string::String) {
        self.bc_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bc_address(&mut self) -> &mut ::std::string::String {
        &mut self.bc_address
    }

    // Take field
    pub fn take_bc_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bc_address, ::std::string::String::new())
    }

    pub fn get_bc_address(&self) -> &str {
        &self.bc_address
    }

    // string collateralized_nrg = 6;

    pub fn clear_collateralized_nrg(&mut self) {
        self.collateralized_nrg.clear();
    }

    // Param is passed by value, moved
    pub fn set_collateralized_nrg(&mut self, v: ::std::string::String) {
        self.collateralized_nrg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collateralized_nrg(&mut self) -> &mut ::std::string::String {
        &mut self.collateralized_nrg
    }

    // Take field
    pub fn take_collateralized_nrg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collateralized_nrg, ::std::string::String::new())
    }

    pub fn get_collateralized_nrg(&self) -> &str {
        &self.collateralized_nrg
    }

    // string block_hash = 7;

    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }

    // uint64 block_height = 8;

    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: u64) {
        self.block_height = v;
    }

    pub fn get_block_height(&self) -> u64 {
        self.block_height
    }
}

impl ::protobuf::Message for TakerOrderInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sends_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wants_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_tx_hash)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maker_tx_output_index = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bc_address)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collateralized_nrg)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_hash)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sends_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sends_address);
        }
        if !self.wants_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.wants_address);
        }
        if !self.maker_tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.maker_tx_hash);
        }
        if self.maker_tx_output_index != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maker_tx_output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.bc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.bc_address);
        }
        if !self.collateralized_nrg.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.collateralized_nrg);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.block_hash);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(8, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.sends_address.is_empty() {
            os.write_string(1, &self.sends_address)?;
        }
        if !self.wants_address.is_empty() {
            os.write_string(2, &self.wants_address)?;
        }
        if !self.maker_tx_hash.is_empty() {
            os.write_string(3, &self.maker_tx_hash)?;
        }
        if self.maker_tx_output_index != 0 {
            os.write_uint32(4, self.maker_tx_output_index)?;
        }
        if !self.bc_address.is_empty() {
            os.write_string(5, &self.bc_address)?;
        }
        if !self.collateralized_nrg.is_empty() {
            os.write_string(6, &self.collateralized_nrg)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(7, &self.block_hash)?;
        }
        if self.block_height != 0 {
            os.write_uint64(8, self.block_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TakerOrderInfo {
        TakerOrderInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sends_address",
                    |m: &TakerOrderInfo| { &m.sends_address },
                    |m: &mut TakerOrderInfo| { &mut m.sends_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wants_address",
                    |m: &TakerOrderInfo| { &m.wants_address },
                    |m: &mut TakerOrderInfo| { &mut m.wants_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "maker_tx_hash",
                    |m: &TakerOrderInfo| { &m.maker_tx_hash },
                    |m: &mut TakerOrderInfo| { &mut m.maker_tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maker_tx_output_index",
                    |m: &TakerOrderInfo| { &m.maker_tx_output_index },
                    |m: &mut TakerOrderInfo| { &mut m.maker_tx_output_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bc_address",
                    |m: &TakerOrderInfo| { &m.bc_address },
                    |m: &mut TakerOrderInfo| { &mut m.bc_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collateralized_nrg",
                    |m: &TakerOrderInfo| { &m.collateralized_nrg },
                    |m: &mut TakerOrderInfo| { &mut m.collateralized_nrg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "block_hash",
                    |m: &TakerOrderInfo| { &m.block_hash },
                    |m: &mut TakerOrderInfo| { &mut m.block_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "block_height",
                    |m: &TakerOrderInfo| { &m.block_height },
                    |m: &mut TakerOrderInfo| { &mut m.block_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TakerOrderInfo>(
                    "TakerOrderInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TakerOrderInfo {
        static mut instance: ::protobuf::lazy::Lazy<TakerOrderInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TakerOrderInfo,
        };
        unsafe {
            instance.get(TakerOrderInfo::new)
        }
    }
}

impl ::protobuf::Clear for TakerOrderInfo {
    fn clear(&mut self) {
        self.clear_sends_address();
        self.clear_wants_address();
        self.clear_maker_tx_hash();
        self.clear_maker_tx_output_index();
        self.clear_bc_address();
        self.clear_collateralized_nrg();
        self.clear_block_hash();
        self.clear_block_height();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TakerOrderInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TakerOrderInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchedOpenOrder {
    // message fields
    pub maker: ::protobuf::SingularPtrField<MakerOrderInfo>,
    pub taker: ::protobuf::SingularPtrField<TakerOrderInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MatchedOpenOrder {
    pub fn new() -> MatchedOpenOrder {
        ::std::default::Default::default()
    }

    // .bc.MakerOrderInfo maker = 1;

    pub fn clear_maker(&mut self) {
        self.maker.clear();
    }

    pub fn has_maker(&self) -> bool {
        self.maker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maker(&mut self, v: MakerOrderInfo) {
        self.maker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker(&mut self) -> &mut MakerOrderInfo {
        if self.maker.is_none() {
            self.maker.set_default();
        }
        self.maker.as_mut().unwrap()
    }

    // Take field
    pub fn take_maker(&mut self) -> MakerOrderInfo {
        self.maker.take().unwrap_or_else(|| MakerOrderInfo::new())
    }

    pub fn get_maker(&self) -> &MakerOrderInfo {
        self.maker.as_ref().unwrap_or_else(|| MakerOrderInfo::default_instance())
    }

    // .bc.TakerOrderInfo taker = 2;

    pub fn clear_taker(&mut self) {
        self.taker.clear();
    }

    pub fn has_taker(&self) -> bool {
        self.taker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taker(&mut self, v: TakerOrderInfo) {
        self.taker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker(&mut self) -> &mut TakerOrderInfo {
        if self.taker.is_none() {
            self.taker.set_default();
        }
        self.taker.as_mut().unwrap()
    }

    // Take field
    pub fn take_taker(&mut self) -> TakerOrderInfo {
        self.taker.take().unwrap_or_else(|| TakerOrderInfo::new())
    }

    pub fn get_taker(&self) -> &TakerOrderInfo {
        self.taker.as_ref().unwrap_or_else(|| TakerOrderInfo::default_instance())
    }
}

impl ::protobuf::Message for MatchedOpenOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.maker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.taker {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.maker)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.taker)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.maker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.taker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.maker.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.taker.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchedOpenOrder {
        MatchedOpenOrder::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MakerOrderInfo>>(
                    "maker",
                    |m: &MatchedOpenOrder| { &m.maker },
                    |m: &mut MatchedOpenOrder| { &mut m.maker },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TakerOrderInfo>>(
                    "taker",
                    |m: &MatchedOpenOrder| { &m.taker },
                    |m: &mut MatchedOpenOrder| { &mut m.taker },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchedOpenOrder>(
                    "MatchedOpenOrder",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchedOpenOrder {
        static mut instance: ::protobuf::lazy::Lazy<MatchedOpenOrder> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchedOpenOrder,
        };
        unsafe {
            instance.get(MatchedOpenOrder::new)
        }
    }
}

impl ::protobuf::Clear for MatchedOpenOrder {
    fn clear(&mut self) {
        self.clear_maker();
        self.clear_taker();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchedOpenOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchedOpenOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetOpenOrdersResponse {
    // message fields
    pub open_orders: ::protobuf::RepeatedField<MakerOrderInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetOpenOrdersResponse {
    pub fn new() -> GetOpenOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated .bc.MakerOrderInfo open_orders = 1;

    pub fn clear_open_orders(&mut self) {
        self.open_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_open_orders(&mut self, v: ::protobuf::RepeatedField<MakerOrderInfo>) {
        self.open_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_open_orders(&mut self) -> &mut ::protobuf::RepeatedField<MakerOrderInfo> {
        &mut self.open_orders
    }

    // Take field
    pub fn take_open_orders(&mut self) -> ::protobuf::RepeatedField<MakerOrderInfo> {
        ::std::mem::replace(&mut self.open_orders, ::protobuf::RepeatedField::new())
    }

    pub fn get_open_orders(&self) -> &[MakerOrderInfo] {
        &self.open_orders
    }
}

impl ::protobuf::Message for GetOpenOrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.open_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.open_orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.open_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.open_orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOpenOrdersResponse {
        GetOpenOrdersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MakerOrderInfo>>(
                    "open_orders",
                    |m: &GetOpenOrdersResponse| { &m.open_orders },
                    |m: &mut GetOpenOrdersResponse| { &mut m.open_orders },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetOpenOrdersResponse>(
                    "GetOpenOrdersResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetOpenOrdersResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetOpenOrdersResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetOpenOrdersResponse,
        };
        unsafe {
            instance.get(GetOpenOrdersResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetOpenOrdersResponse {
    fn clear(&mut self) {
        self.clear_open_orders();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOpenOrdersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOpenOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetMatchedOpenOrdersResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<MatchedOpenOrder>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetMatchedOpenOrdersResponse {
    pub fn new() -> GetMatchedOpenOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated .bc.MatchedOpenOrder orders = 1;

    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<MatchedOpenOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<MatchedOpenOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<MatchedOpenOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }

    pub fn get_orders(&self) -> &[MatchedOpenOrder] {
        &self.orders
    }
}

impl ::protobuf::Message for GetMatchedOpenOrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMatchedOpenOrdersResponse {
        GetMatchedOpenOrdersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchedOpenOrder>>(
                    "orders",
                    |m: &GetMatchedOpenOrdersResponse| { &m.orders },
                    |m: &mut GetMatchedOpenOrdersResponse| { &mut m.orders },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetMatchedOpenOrdersResponse>(
                    "GetMatchedOpenOrdersResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetMatchedOpenOrdersResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetMatchedOpenOrdersResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetMatchedOpenOrdersResponse,
        };
        unsafe {
            instance.get(GetMatchedOpenOrdersResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetMatchedOpenOrdersResponse {
    fn clear(&mut self) {
        self.clear_orders();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMatchedOpenOrdersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMatchedOpenOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlaceMakerOrderRequest {
    // message fields
    pub shift_starts_at: u64,
    pub deposit_ends_at: u64,
    pub settle_ends_at: u64,
    pub pays_with_chain_id: ::std::string::String,
    pub wants_chain_id: ::std::string::String,
    pub wants_chain_address: ::std::string::String,
    pub wants_unit: ::std::string::String,
    pub pays_unit: ::std::string::String,
    pub bc_address: ::std::string::String,
    pub bc_private_key_hex: ::std::string::String,
    pub collateralized_nrg: ::std::string::String,
    pub nrg_unit: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PlaceMakerOrderRequest {
    pub fn new() -> PlaceMakerOrderRequest {
        ::std::default::Default::default()
    }

    // uint64 shift_starts_at = 1;

    pub fn clear_shift_starts_at(&mut self) {
        self.shift_starts_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_shift_starts_at(&mut self, v: u64) {
        self.shift_starts_at = v;
    }

    pub fn get_shift_starts_at(&self) -> u64 {
        self.shift_starts_at
    }

    // uint64 deposit_ends_at = 2;

    pub fn clear_deposit_ends_at(&mut self) {
        self.deposit_ends_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_deposit_ends_at(&mut self, v: u64) {
        self.deposit_ends_at = v;
    }

    pub fn get_deposit_ends_at(&self) -> u64 {
        self.deposit_ends_at
    }

    // uint64 settle_ends_at = 3;

    pub fn clear_settle_ends_at(&mut self) {
        self.settle_ends_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_ends_at(&mut self, v: u64) {
        self.settle_ends_at = v;
    }

    pub fn get_settle_ends_at(&self) -> u64 {
        self.settle_ends_at
    }

    // string pays_with_chain_id = 4;

    pub fn clear_pays_with_chain_id(&mut self) {
        self.pays_with_chain_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pays_with_chain_id(&mut self, v: ::std::string::String) {
        self.pays_with_chain_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pays_with_chain_id(&mut self) -> &mut ::std::string::String {
        &mut self.pays_with_chain_id
    }

    // Take field
    pub fn take_pays_with_chain_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pays_with_chain_id, ::std::string::String::new())
    }

    pub fn get_pays_with_chain_id(&self) -> &str {
        &self.pays_with_chain_id
    }

    // string wants_chain_id = 5;

    pub fn clear_wants_chain_id(&mut self) {
        self.wants_chain_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_wants_chain_id(&mut self, v: ::std::string::String) {
        self.wants_chain_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wants_chain_id(&mut self) -> &mut ::std::string::String {
        &mut self.wants_chain_id
    }

    // Take field
    pub fn take_wants_chain_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wants_chain_id, ::std::string::String::new())
    }

    pub fn get_wants_chain_id(&self) -> &str {
        &self.wants_chain_id
    }

    // string wants_chain_address = 6;

    pub fn clear_wants_chain_address(&mut self) {
        self.wants_chain_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_wants_chain_address(&mut self, v: ::std::string::String) {
        self.wants_chain_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wants_chain_address(&mut self) -> &mut ::std::string::String {
        &mut self.wants_chain_address
    }

    // Take field
    pub fn take_wants_chain_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wants_chain_address, ::std::string::String::new())
    }

    pub fn get_wants_chain_address(&self) -> &str {
        &self.wants_chain_address
    }

    // string wants_unit = 7;

    pub fn clear_wants_unit(&mut self) {
        self.wants_unit.clear();
    }

    // Param is passed by value, moved
    pub fn set_wants_unit(&mut self, v: ::std::string::String) {
        self.wants_unit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wants_unit(&mut self) -> &mut ::std::string::String {
        &mut self.wants_unit
    }

    // Take field
    pub fn take_wants_unit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wants_unit, ::std::string::String::new())
    }

    pub fn get_wants_unit(&self) -> &str {
        &self.wants_unit
    }

    // string pays_unit = 8;

    pub fn clear_pays_unit(&mut self) {
        self.pays_unit.clear();
    }

    // Param is passed by value, moved
    pub fn set_pays_unit(&mut self, v: ::std::string::String) {
        self.pays_unit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pays_unit(&mut self) -> &mut ::std::string::String {
        &mut self.pays_unit
    }

    // Take field
    pub fn take_pays_unit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pays_unit, ::std::string::String::new())
    }

    pub fn get_pays_unit(&self) -> &str {
        &self.pays_unit
    }

    // string bc_address = 9;

    pub fn clear_bc_address(&mut self) {
        self.bc_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_bc_address(&mut self, v: ::std::string::String) {
        self.bc_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bc_address(&mut self) -> &mut ::std::string::String {
        &mut self.bc_address
    }

    // Take field
    pub fn take_bc_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bc_address, ::std::string::String::new())
    }

    pub fn get_bc_address(&self) -> &str {
        &self.bc_address
    }

    // string bc_private_key_hex = 10;

    pub fn clear_bc_private_key_hex(&mut self) {
        self.bc_private_key_hex.clear();
    }

    // Param is passed by value, moved
    pub fn set_bc_private_key_hex(&mut self, v: ::std::string::String) {
        self.bc_private_key_hex = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bc_private_key_hex(&mut self) -> &mut ::std::string::String {
        &mut self.bc_private_key_hex
    }

    // Take field
    pub fn take_bc_private_key_hex(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bc_private_key_hex, ::std::string::String::new())
    }

    pub fn get_bc_private_key_hex(&self) -> &str {
        &self.bc_private_key_hex
    }

    // string collateralized_nrg = 11;

    pub fn clear_collateralized_nrg(&mut self) {
        self.collateralized_nrg.clear();
    }

    // Param is passed by value, moved
    pub fn set_collateralized_nrg(&mut self, v: ::std::string::String) {
        self.collateralized_nrg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collateralized_nrg(&mut self) -> &mut ::std::string::String {
        &mut self.collateralized_nrg
    }

    // Take field
    pub fn take_collateralized_nrg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collateralized_nrg, ::std::string::String::new())
    }

    pub fn get_collateralized_nrg(&self) -> &str {
        &self.collateralized_nrg
    }

    // string nrg_unit = 12;

    pub fn clear_nrg_unit(&mut self) {
        self.nrg_unit.clear();
    }

    // Param is passed by value, moved
    pub fn set_nrg_unit(&mut self, v: ::std::string::String) {
        self.nrg_unit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nrg_unit(&mut self) -> &mut ::std::string::String {
        &mut self.nrg_unit
    }

    // Take field
    pub fn take_nrg_unit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nrg_unit, ::std::string::String::new())
    }

    pub fn get_nrg_unit(&self) -> &str {
        &self.nrg_unit
    }
}

impl ::protobuf::Message for PlaceMakerOrderRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.shift_starts_at = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.deposit_ends_at = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.settle_ends_at = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pays_with_chain_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wants_chain_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wants_chain_address)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wants_unit)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pays_unit)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bc_address)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bc_private_key_hex)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collateralized_nrg)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nrg_unit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shift_starts_at != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shift_starts_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.deposit_ends_at != 0 {
            my_size += ::protobuf::rt::value_size(2, self.deposit_ends_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_ends_at != 0 {
            my_size += ::protobuf::rt::value_size(3, self.settle_ends_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pays_with_chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.pays_with_chain_id);
        }
        if !self.wants_chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.wants_chain_id);
        }
        if !self.wants_chain_address.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.wants_chain_address);
        }
        if !self.wants_unit.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.wants_unit);
        }
        if !self.pays_unit.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.pays_unit);
        }
        if !self.bc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.bc_address);
        }
        if !self.bc_private_key_hex.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.bc_private_key_hex);
        }
        if !self.collateralized_nrg.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.collateralized_nrg);
        }
        if !self.nrg_unit.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.nrg_unit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.shift_starts_at != 0 {
            os.write_uint64(1, self.shift_starts_at)?;
        }
        if self.deposit_ends_at != 0 {
            os.write_uint64(2, self.deposit_ends_at)?;
        }
        if self.settle_ends_at != 0 {
            os.write_uint64(3, self.settle_ends_at)?;
        }
        if !self.pays_with_chain_id.is_empty() {
            os.write_string(4, &self.pays_with_chain_id)?;
        }
        if !self.wants_chain_id.is_empty() {
            os.write_string(5, &self.wants_chain_id)?;
        }
        if !self.wants_chain_address.is_empty() {
            os.write_string(6, &self.wants_chain_address)?;
        }
        if !self.wants_unit.is_empty() {
            os.write_string(7, &self.wants_unit)?;
        }
        if !self.pays_unit.is_empty() {
            os.write_string(8, &self.pays_unit)?;
        }
        if !self.bc_address.is_empty() {
            os.write_string(9, &self.bc_address)?;
        }
        if !self.bc_private_key_hex.is_empty() {
            os.write_string(10, &self.bc_private_key_hex)?;
        }
        if !self.collateralized_nrg.is_empty() {
            os.write_string(11, &self.collateralized_nrg)?;
        }
        if !self.nrg_unit.is_empty() {
            os.write_string(12, &self.nrg_unit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlaceMakerOrderRequest {
        PlaceMakerOrderRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "shift_starts_at",
                    |m: &PlaceMakerOrderRequest| { &m.shift_starts_at },
                    |m: &mut PlaceMakerOrderRequest| { &mut m.shift_starts_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "deposit_ends_at",
                    |m: &PlaceMakerOrderRequest| { &m.deposit_ends_at },
                    |m: &mut PlaceMakerOrderRequest| { &mut m.deposit_ends_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "settle_ends_at",
                    |m: &PlaceMakerOrderRequest| { &m.settle_ends_at },
                    |m: &mut PlaceMakerOrderRequest| { &mut m.settle_ends_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pays_with_chain_id",
                    |m: &PlaceMakerOrderRequest| { &m.pays_with_chain_id },
                    |m: &mut PlaceMakerOrderRequest| { &mut m.pays_with_chain_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wants_chain_id",
                    |m: &PlaceMakerOrderRequest| { &m.wants_chain_id },
                    |m: &mut PlaceMakerOrderRequest| { &mut m.wants_chain_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wants_chain_address",
                    |m: &PlaceMakerOrderRequest| { &m.wants_chain_address },
                    |m: &mut PlaceMakerOrderRequest| { &mut m.wants_chain_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wants_unit",
                    |m: &PlaceMakerOrderRequest| { &m.wants_unit },
                    |m: &mut PlaceMakerOrderRequest| { &mut m.wants_unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pays_unit",
                    |m: &PlaceMakerOrderRequest| { &m.pays_unit },
                    |m: &mut PlaceMakerOrderRequest| { &mut m.pays_unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bc_address",
                    |m: &PlaceMakerOrderRequest| { &m.bc_address },
                    |m: &mut PlaceMakerOrderRequest| { &mut m.bc_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bc_private_key_hex",
                    |m: &PlaceMakerOrderRequest| { &m.bc_private_key_hex },
                    |m: &mut PlaceMakerOrderRequest| { &mut m.bc_private_key_hex },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collateralized_nrg",
                    |m: &PlaceMakerOrderRequest| { &m.collateralized_nrg },
                    |m: &mut PlaceMakerOrderRequest| { &mut m.collateralized_nrg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nrg_unit",
                    |m: &PlaceMakerOrderRequest| { &m.nrg_unit },
                    |m: &mut PlaceMakerOrderRequest| { &mut m.nrg_unit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlaceMakerOrderRequest>(
                    "PlaceMakerOrderRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlaceMakerOrderRequest {
        static mut instance: ::protobuf::lazy::Lazy<PlaceMakerOrderRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlaceMakerOrderRequest,
        };
        unsafe {
            instance.get(PlaceMakerOrderRequest::new)
        }
    }
}

impl ::protobuf::Clear for PlaceMakerOrderRequest {
    fn clear(&mut self) {
        self.clear_shift_starts_at();
        self.clear_deposit_ends_at();
        self.clear_settle_ends_at();
        self.clear_pays_with_chain_id();
        self.clear_wants_chain_id();
        self.clear_wants_chain_address();
        self.clear_wants_unit();
        self.clear_pays_unit();
        self.clear_bc_address();
        self.clear_bc_private_key_hex();
        self.clear_collateralized_nrg();
        self.clear_nrg_unit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlaceMakerOrderRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlaceMakerOrderRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlaceTakerOrderRequest {
    // message fields
    pub wants_chain_address: ::std::string::String,
    pub sends_chain_address: ::std::string::String,
    pub maker_tx_hash: ::std::string::String,
    pub maker_tx_output_index: u32,
    pub bc_address: ::std::string::String,
    pub bc_private_key_hex: ::std::string::String,
    pub collateralized_nrg: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PlaceTakerOrderRequest {
    pub fn new() -> PlaceTakerOrderRequest {
        ::std::default::Default::default()
    }

    // string wants_chain_address = 1;

    pub fn clear_wants_chain_address(&mut self) {
        self.wants_chain_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_wants_chain_address(&mut self, v: ::std::string::String) {
        self.wants_chain_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wants_chain_address(&mut self) -> &mut ::std::string::String {
        &mut self.wants_chain_address
    }

    // Take field
    pub fn take_wants_chain_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wants_chain_address, ::std::string::String::new())
    }

    pub fn get_wants_chain_address(&self) -> &str {
        &self.wants_chain_address
    }

    // string sends_chain_address = 2;

    pub fn clear_sends_chain_address(&mut self) {
        self.sends_chain_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_sends_chain_address(&mut self, v: ::std::string::String) {
        self.sends_chain_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sends_chain_address(&mut self) -> &mut ::std::string::String {
        &mut self.sends_chain_address
    }

    // Take field
    pub fn take_sends_chain_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sends_chain_address, ::std::string::String::new())
    }

    pub fn get_sends_chain_address(&self) -> &str {
        &self.sends_chain_address
    }

    // string maker_tx_hash = 3;

    pub fn clear_maker_tx_hash(&mut self) {
        self.maker_tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_tx_hash(&mut self, v: ::std::string::String) {
        self.maker_tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.maker_tx_hash
    }

    // Take field
    pub fn take_maker_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_tx_hash, ::std::string::String::new())
    }

    pub fn get_maker_tx_hash(&self) -> &str {
        &self.maker_tx_hash
    }

    // uint32 maker_tx_output_index = 4;

    pub fn clear_maker_tx_output_index(&mut self) {
        self.maker_tx_output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_maker_tx_output_index(&mut self, v: u32) {
        self.maker_tx_output_index = v;
    }

    pub fn get_maker_tx_output_index(&self) -> u32 {
        self.maker_tx_output_index
    }

    // string bc_address = 5;

    pub fn clear_bc_address(&mut self) {
        self.bc_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_bc_address(&mut self, v: ::std::string::String) {
        self.bc_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bc_address(&mut self) -> &mut ::std::string::String {
        &mut self.bc_address
    }

    // Take field
    pub fn take_bc_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bc_address, ::std::string::String::new())
    }

    pub fn get_bc_address(&self) -> &str {
        &self.bc_address
    }

    // string bc_private_key_hex = 6;

    pub fn clear_bc_private_key_hex(&mut self) {
        self.bc_private_key_hex.clear();
    }

    // Param is passed by value, moved
    pub fn set_bc_private_key_hex(&mut self, v: ::std::string::String) {
        self.bc_private_key_hex = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bc_private_key_hex(&mut self) -> &mut ::std::string::String {
        &mut self.bc_private_key_hex
    }

    // Take field
    pub fn take_bc_private_key_hex(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bc_private_key_hex, ::std::string::String::new())
    }

    pub fn get_bc_private_key_hex(&self) -> &str {
        &self.bc_private_key_hex
    }

    // string collateralized_nrg = 7;

    pub fn clear_collateralized_nrg(&mut self) {
        self.collateralized_nrg.clear();
    }

    // Param is passed by value, moved
    pub fn set_collateralized_nrg(&mut self, v: ::std::string::String) {
        self.collateralized_nrg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collateralized_nrg(&mut self) -> &mut ::std::string::String {
        &mut self.collateralized_nrg
    }

    // Take field
    pub fn take_collateralized_nrg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collateralized_nrg, ::std::string::String::new())
    }

    pub fn get_collateralized_nrg(&self) -> &str {
        &self.collateralized_nrg
    }
}

impl ::protobuf::Message for PlaceTakerOrderRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wants_chain_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sends_chain_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_tx_hash)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maker_tx_output_index = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bc_address)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bc_private_key_hex)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collateralized_nrg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.wants_chain_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.wants_chain_address);
        }
        if !self.sends_chain_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sends_chain_address);
        }
        if !self.maker_tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.maker_tx_hash);
        }
        if self.maker_tx_output_index != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maker_tx_output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.bc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.bc_address);
        }
        if !self.bc_private_key_hex.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.bc_private_key_hex);
        }
        if !self.collateralized_nrg.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.collateralized_nrg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.wants_chain_address.is_empty() {
            os.write_string(1, &self.wants_chain_address)?;
        }
        if !self.sends_chain_address.is_empty() {
            os.write_string(2, &self.sends_chain_address)?;
        }
        if !self.maker_tx_hash.is_empty() {
            os.write_string(3, &self.maker_tx_hash)?;
        }
        if self.maker_tx_output_index != 0 {
            os.write_uint32(4, self.maker_tx_output_index)?;
        }
        if !self.bc_address.is_empty() {
            os.write_string(5, &self.bc_address)?;
        }
        if !self.bc_private_key_hex.is_empty() {
            os.write_string(6, &self.bc_private_key_hex)?;
        }
        if !self.collateralized_nrg.is_empty() {
            os.write_string(7, &self.collateralized_nrg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlaceTakerOrderRequest {
        PlaceTakerOrderRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wants_chain_address",
                    |m: &PlaceTakerOrderRequest| { &m.wants_chain_address },
                    |m: &mut PlaceTakerOrderRequest| { &mut m.wants_chain_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sends_chain_address",
                    |m: &PlaceTakerOrderRequest| { &m.sends_chain_address },
                    |m: &mut PlaceTakerOrderRequest| { &mut m.sends_chain_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "maker_tx_hash",
                    |m: &PlaceTakerOrderRequest| { &m.maker_tx_hash },
                    |m: &mut PlaceTakerOrderRequest| { &mut m.maker_tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maker_tx_output_index",
                    |m: &PlaceTakerOrderRequest| { &m.maker_tx_output_index },
                    |m: &mut PlaceTakerOrderRequest| { &mut m.maker_tx_output_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bc_address",
                    |m: &PlaceTakerOrderRequest| { &m.bc_address },
                    |m: &mut PlaceTakerOrderRequest| { &mut m.bc_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bc_private_key_hex",
                    |m: &PlaceTakerOrderRequest| { &m.bc_private_key_hex },
                    |m: &mut PlaceTakerOrderRequest| { &mut m.bc_private_key_hex },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collateralized_nrg",
                    |m: &PlaceTakerOrderRequest| { &m.collateralized_nrg },
                    |m: &mut PlaceTakerOrderRequest| { &mut m.collateralized_nrg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlaceTakerOrderRequest>(
                    "PlaceTakerOrderRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlaceTakerOrderRequest {
        static mut instance: ::protobuf::lazy::Lazy<PlaceTakerOrderRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlaceTakerOrderRequest,
        };
        unsafe {
            instance.get(PlaceTakerOrderRequest::new)
        }
    }
}

impl ::protobuf::Clear for PlaceTakerOrderRequest {
    fn clear(&mut self) {
        self.clear_wants_chain_address();
        self.clear_sends_chain_address();
        self.clear_maker_tx_hash();
        self.clear_maker_tx_output_index();
        self.clear_bc_address();
        self.clear_bc_private_key_hex();
        self.clear_collateralized_nrg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlaceTakerOrderRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlaceTakerOrderRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RpcTransactionResponseStatus {
    Success = 0,
    Failure = 1,
}

impl ::protobuf::ProtobufEnum for RpcTransactionResponseStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RpcTransactionResponseStatus> {
        match value {
            0 => ::std::option::Option::Some(RpcTransactionResponseStatus::Success),
            1 => ::std::option::Option::Some(RpcTransactionResponseStatus::Failure),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RpcTransactionResponseStatus] = &[
            RpcTransactionResponseStatus::Success,
            RpcTransactionResponseStatus::Failure,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RpcTransactionResponseStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RpcTransactionResponseStatus {
}

impl ::std::default::Default for RpcTransactionResponseStatus {
    fn default() -> Self {
        RpcTransactionResponseStatus::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcTransactionResponseStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x08bc.proto\x12\x02bc\x1a\ncore.proto\"<\n\x17GetLatestBlocksResponse\
    \x12!\n\x06blocks\x18\x01\x20\x03(\x0b2\t.bc.BlockR\x06blocks\"+\n\x0cHe\
    lpResponse\x12\x1b\n\thelp_text\x18\x01\x20\x01(\tR\x08helpText\"%\n\rSt\
    atsResponse\x12\x14\n\x05calls\x18\x01\x20\x01(\x03R\x05calls\"\x9d\x01\
    \n\x0eRpcTransaction\x12\x1b\n\tfrom_addr\x18\x01\x20\x01(\tR\x08fromAdd\
    r\x12\x17\n\x07to_addr\x18\x02\x20\x01(\tR\x06toAddr\x12\x16\n\x06amount\
    \x18\x03\x20\x01(\x0cR\x06amount\x12\x15\n\x06tx_fee\x18\x04\x20\x01(\
    \x0cR\x05txFee\x12&\n\x0fprivate_key_hex\x18\x05\x20\x01(\tR\rprivateKey\
    Hex\"\x81\x01\n\x16RpcTransactionResponse\x128\n\x06status\x18\x01\x20\
    \x01(\x0e2\x20.bc.RpcTransactionResponseStatusR\x06status\x12\x17\n\x07t\
    x_hash\x18\x02\x20\x01(\tR\x06txHash\x12\x14\n\x05error\x18\x03\x20\x01(\
    \tR\x05error\"-\n\x11GetBalanceRequest\x12\x18\n\x07address\x18\x01\x20\
    \x01(\tR\x07address\"h\n\x12GetBalanceResponse\x12\x1c\n\tconfirmed\x18\
    \x01\x20\x01(\tR\tconfirmed\x12\x20\n\x0bunconfirmed\x18\x02\x20\x01(\tR\
    \x0bunconfirmed\x12\x12\n\x04unit\x18\x03\x20\x01(\tR\x04unit\"\x9d\x04\
    \n\x0eMakerOrderInfo\x12&\n\x0fshift_starts_at\x18\x01\x20\x01(\x04R\rsh\
    iftStartsAt\x12&\n\x0fdeposit_ends_at\x18\x02\x20\x01(\x04R\rdepositEnds\
    At\x12$\n\x0esettle_ends_at\x18\x03\x20\x01(\x04R\x0csettleEndsAt\x12\"\
    \n\rpays_chain_id\x18\x04\x20\x01(\tR\x0bpaysChainId\x12$\n\x0ewants_cha\
    in_id\x18\x05\x20\x01(\tR\x0cwantsChainId\x12#\n\rwants_address\x18\x06\
    \x20\x01(\tR\x0cwantsAddress\x12\x1d\n\nwants_unit\x18\x07\x20\x01(\tR\t\
    wantsUnit\x12\x1b\n\tpays_unit\x18\x08\x20\x01(\tR\x08paysUnit\x12\x1d\n\
    \nbc_address\x18\t\x20\x01(\tR\tbcAddress\x12-\n\x12collateralized_nrg\
    \x18\n\x20\x01(\tR\x11collateralizedNrg\x12\x19\n\x08nrg_unit\x18\x0b\
    \x20\x01(\tR\x07nrgUnit\x12\x17\n\x07tx_hash\x18\x0c\x20\x01(\tR\x06txHa\
    sh\x12&\n\x0ftx_output_index\x18\r\x20\x01(\x04R\rtxOutputIndex\x12\x1d\
    \n\nblock_hash\x18\x0e\x20\x01(\tR\tblockHash\x12!\n\x0cblock_height\x18\
    \x0f\x20\x01(\x04R\x0bblockHeight\"\xc1\x02\n\x0eTakerOrderInfo\x12#\n\r\
    sends_address\x18\x01\x20\x01(\tR\x0csendsAddress\x12#\n\rwants_address\
    \x18\x02\x20\x01(\tR\x0cwantsAddress\x12\"\n\rmaker_tx_hash\x18\x03\x20\
    \x01(\tR\x0bmakerTxHash\x121\n\x15maker_tx_output_index\x18\x04\x20\x01(\
    \rR\x12makerTxOutputIndex\x12\x1d\n\nbc_address\x18\x05\x20\x01(\tR\tbcA\
    ddress\x12-\n\x12collateralized_nrg\x18\x06\x20\x01(\tR\x11collateralize\
    dNrg\x12\x1d\n\nblock_hash\x18\x07\x20\x01(\tR\tblockHash\x12!\n\x0cbloc\
    k_height\x18\x08\x20\x01(\x04R\x0bblockHeight\"f\n\x10MatchedOpenOrder\
    \x12(\n\x05maker\x18\x01\x20\x01(\x0b2\x12.bc.MakerOrderInfoR\x05maker\
    \x12(\n\x05taker\x18\x02\x20\x01(\x0b2\x12.bc.TakerOrderInfoR\x05taker\"\
    L\n\x15GetOpenOrdersResponse\x123\n\x0bopen_orders\x18\x01\x20\x03(\x0b2\
    \x12.bc.MakerOrderInfoR\nopenOrders\"L\n\x1cGetMatchedOpenOrdersResponse\
    \x12,\n\x06orders\x18\x01\x20\x03(\x0b2\x14.bc.MatchedOpenOrderR\x06orde\
    rs\"\xe3\x03\n\x16PlaceMakerOrderRequest\x12&\n\x0fshift_starts_at\x18\
    \x01\x20\x01(\x04R\rshiftStartsAt\x12&\n\x0fdeposit_ends_at\x18\x02\x20\
    \x01(\x04R\rdepositEndsAt\x12$\n\x0esettle_ends_at\x18\x03\x20\x01(\x04R\
    \x0csettleEndsAt\x12+\n\x12pays_with_chain_id\x18\x04\x20\x01(\tR\x0fpay\
    sWithChainId\x12$\n\x0ewants_chain_id\x18\x05\x20\x01(\tR\x0cwantsChainI\
    d\x12.\n\x13wants_chain_address\x18\x06\x20\x01(\tR\x11wantsChainAddress\
    \x12\x1d\n\nwants_unit\x18\x07\x20\x01(\tR\twantsUnit\x12\x1b\n\tpays_un\
    it\x18\x08\x20\x01(\tR\x08paysUnit\x12\x1d\n\nbc_address\x18\t\x20\x01(\
    \tR\tbcAddress\x12+\n\x12bc_private_key_hex\x18\n\x20\x01(\tR\x0fbcPriva\
    teKeyHex\x12-\n\x12collateralized_nrg\x18\x0b\x20\x01(\tR\x11collaterali\
    zedNrg\x12\x19\n\x08nrg_unit\x18\x0c\x20\x01(\tR\x07nrgUnit\"\xca\x02\n\
    \x16PlaceTakerOrderRequest\x12.\n\x13wants_chain_address\x18\x01\x20\x01\
    (\tR\x11wantsChainAddress\x12.\n\x13sends_chain_address\x18\x02\x20\x01(\
    \tR\x11sendsChainAddress\x12\"\n\rmaker_tx_hash\x18\x03\x20\x01(\tR\x0bm\
    akerTxHash\x121\n\x15maker_tx_output_index\x18\x04\x20\x01(\rR\x12makerT\
    xOutputIndex\x12\x1d\n\nbc_address\x18\x05\x20\x01(\tR\tbcAddress\x12+\n\
    \x12bc_private_key_hex\x18\x06\x20\x01(\tR\x0fbcPrivateKeyHex\x12-\n\x12\
    collateralized_nrg\x18\x07\x20\x01(\tR\x11collateralizedNrg*8\n\x1cRpcTr\
    ansactionResponseStatus\x12\x0b\n\x07Success\x10\0\x12\x0b\n\x07Failure\
    \x10\x012\xa0\x04\n\x02Bc\x12:\n\x0fGetLatestBlocks\x12\x08.bc.Null\x1a\
    \x1b.bc.GetLatestBlocksResponse\"\0\x12$\n\x04Help\x12\x08.bc.Null\x1a\
    \x10.bc.HelpResponse\"\0\x12&\n\x05Stats\x12\x08.bc.Null\x1a\x11.bc.Stat\
    sResponse\"\0\x129\n\x05NewTx\x12\x12.bc.RpcTransaction\x1a\x1a.bc.RpcTr\
    ansactionResponse\"\0\x12=\n\nGetBalance\x12\x15.bc.GetBalanceRequest\
    \x1a\x16.bc.GetBalanceResponse\"\0\x12K\n\x0fPlaceMakerOrder\x12\x1a.bc.\
    PlaceMakerOrderRequest\x1a\x1a.bc.RpcTransactionResponse\"\0\x12K\n\x0fP\
    laceTakerOrder\x12\x1a.bc.PlaceTakerOrderRequest\x1a\x1a.bc.RpcTransacti\
    onResponse\"\0\x126\n\rGetOpenOrders\x12\x08.bc.Null\x1a\x19.bc.GetOpenO\
    rdersResponse\"\0\x12D\n\x14GetMatchedOpenOrders\x12\x08.bc.Null\x1a\x20\
    .bc.GetMatchedOpenOrdersResponse\"\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
